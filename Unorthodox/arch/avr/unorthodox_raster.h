
/*
  nano operating system for the Arduino (Leonardo)  (c) Jeremy Lee 2013
 */

#ifndef unorthodox_raster_h
#define unorthodox_raster_h
#include <Arduino.h>

class Raster {
public:
	static const byte RIGHT = 1;
	static const byte DOWN = 2;
	static const byte LEFT = 3;
	static const byte UP = 4;
	word width;
	word height;
	virtual void fragment(word x, word y, byte dir, Page * pixels, word index, word count) = 0;
	virtual void pixel(word x, word y, byte r, byte g, byte b) = 0;
};

class Raster8 : public Raster {
public:
	virtual byte color(byte r, byte g, byte b) = 0;
	void pixel(word x, word y, byte r, byte g, byte b) {
		// convert the color to a single byte
		byte col = color(r,g,b);
		// create a memory page to hold it
		MemoryPage pixels(&col);
		// send it to the device
		fragment(x,y,Raster::RIGHT,&pixels,0,1);
	}
};

class Raster16 : public Raster {
public:
	virtual word color(byte r, byte g, byte b) = 0;
	void pixel(word x, word y, byte r, byte g, byte b) {
		// convert the color to a single byte
		word col = color(r,g,b);
		// create a memory page to hold it
		MemoryPage pixels((byte *)&col);
		// send it to the device
		fragment(x,y,Raster::RIGHT, &pixels,0,1);
	}
};

class ILI9325C : public Raster16 {
public:
	ILI9325C() {
		width = 320;
		height = 240;
		// start();
	}
	~ILI9325C() {
		// stop();
	}
	void fragment(word x, word y, byte dir, Page * pixels, word index, word count) {
		// determine entry mode
		byte m1 = 0x10; byte m2=0x30;
		switch(dir) {
			case Raster::RIGHT: m2 = 0x30; break;
			case Raster::DOWN:  m2 = 0x38; break;
			case Raster::LEFT:  m2 = 0x20; break;
			case Raster::UP:    m2 = 0x18; break;
		}
		// raster cursor position
		word block[3*3+1]  = {
			0x103, m1, m2,
			0x120, x >> 8, x & 0xFF,
			0x121, y >> 8, y & 0xFF,
			0x122
		};
		chip_select();
		write_commands(block, 3*3+1); // write the cursor block
		write_page(pixels,index,count*2); // now write out the pixel data
		chip_deselect();
	}
	word color(byte r, byte g, byte b) {
		word w = 0;
		w |= (r & 0xF8) << 8;
		w |= (g & 0xFC) << 3;
		w |= (b & 0xF8) >> 3;
		return w;
	}
	void start() {
		// perform a complete reset
		chip_reset();
		// initialize
		chip_select();
		word block1[3*16]  = {
			0x1E5, 0x78, 0xF0, // SRAM internal timing
			0x101, 0x01, 0x00, // Driver Output Control  
			0x102, 0x07, 0x00, // Line inversion  
			0x103, 0x00, 0x30, // GRAM write direction 
			0x104, 0x00, 0x00, // Resize register  
			0x108, 0x02, 0x07, // back porch and front porch  
			0x109, 0x00, 0x00, // non-display area refresh cycle ISC[3:0]  
			0x10A, 0x00, 0x00, // FMARK function  
			0x10C, 0x00, 0x00, // RGB interface setting  
			0x10D, 0x00, 0x00, // Frame marker Position  
			0x10F, 0x00, 0x00, // RGB interface polarity  
			// Power On sequence 
			0x110, 0x00, 0x00, // SAP, BT[3:0], AP, DSTB, SLP, STB  
			0x111, 0x00, 0x07, // DC1[2:0], DC0[2:0], VC[2:0]  
			0x112, 0x00, 0x00, // VREG1OUT voltage  
			0x113, 0x00, 0x00, // VDV[4:0] for VCOM amplitude  
			0x107, 0x00, 0x01
		};
		write_commands(block1, 3*16);
		delay(200); // wait for capacitor discharge 
		word block2[3*2] = {
			0x110, 0x10, 0x90, // SAP, BT[3:0], AP, DSTB, SLP, STB  
			0x111, 0x02, 0x27  // Set DC1[2:0], DC0[2:0], VC[2:0]  
		};
		write_commands(block2, 3*2);
		delay(50); // wait 50ms  
		word block3[3*1] = {
			0x112, 0x00, 0x1F // 0012  
		};
		write_commands(block3, 3*1);
		delay(50); // wait 50ms  
		word block4[3*3] = {
			0x113, 0x15, 0x00, // VDV[4:0] for VCOM amplitude  
			0x129, 0x00, 0x27, // 04  VCM[5:0] for VCOMH  
			0x12B, 0x00, 0x0D  // Set Frame Rate  
		};
		write_commands(block4, 3*3);
		delay(50); // wait 50ms  
		word block5[3*28] = {
			0x120, 0x00, 0x00, // GRAM horizontal Address  
			0x121, 0x00, 0x00, // GRAM Vertical Address  
			// Adjust the Gamma Curve
			/* 0x130, 0x00, 0x00,  
			0x131, 0x07, 0x07,  
			0x132, 0x03, 0x07,  
			0x135, 0x02, 0x00,  
			0x136, 0x00, 0x08,  
			0x137, 0x00, 0x04,  
			0x138, 0x00, 0x00,  
			0x139, 0x07, 0x07,  
			0x13C, 0x00, 0x02,  
			0x13D, 0x1D, 0x04,  */
			0x130, 0x00, 0x00,  
			0x131, 0x00, 0x00,  
			0x132, 0x00, 0x00,  
			0x135, 0x00, 0x00,  
			0x136, 0x00, 0x00,  
			0x137, 0x00, 0x00,  
			0x138, 0x00, 0x00,  
			0x139, 0x00, 0x00,  
			0x13C, 0x00, 0x00,  
			0x13D, 0x00, 0x00, 
			// Set GRAM area 
			0x150, 0x00, 0x00, // Horizontal GRAM Start Address  
			0x151, 0x00, 0xEF, // Horizontal GRAM End Address  
			0x152, 0x00, 0x00, // Vertical GRAM Start Address  
			0x153, 0x01, 0x3F, // Vertical GRAM End Address  
			0x160, 0xA7, 0x00, // Gate Scan Line  
			0x161, 0x00, 0x03, // NDL, VLE, REV   
			0x16A, 0x00, 0x00, // Scrolling  
			// Partial Display Control 
			0x180, 0x00, 0x00,  
			0x181, 0x00, 0x00,  
			0x182, 0x00, 0x00,  
			0x183, 0x00, 0x00,  
			0x184, 0x00, 0x00,  
			0x185, 0x00, 0x00,  
			// Panel Control
			0x190, 0x00, 0x10,  
			0x192, 0x06, 0x00,  
			0x107, 0x01, 0x33  // 262K color and display ON        
		};
		write_commands(block5, 3*28);
		chip_deselect();
	}
	void idle() {}
	void stop() {}
	void scroll(int y) {
		y = y % 320;
		byte yl = y;
		byte yh = y>>8;
		word block3[3*1] = {
			0x16A, yh, yl,
		};
		chip_select();
		write_commands(block3, 3*1);
		chip_deselect();
	}
private:
	virtual void chip_reset() = 0;
	virtual void chip_select() = 0;
	virtual void chip_deselect() = 0;
	virtual void write_page(Page * page, word index, word count) = 0;
	virtual void write_commands(word * data, word count) = 0;
};

/*
 * This variant assumes the D0-7 lines are neatly mapped to Pins 0-7, and is slow as hell.
 */
class ILI9325C_Pins : public ILI9325C {
private:
	int _rs_pin;
	int _wr_pin;
	int _cs_pin;
	int _rst_pin;
public:
	ILI9325C_Pins(int rs, int wr, int cs, int rst) : ILI9325C() {
		// D0-7 lower bits become outputs
		for(byte i=0; i<8; i++) { digitalWrite(i,LOW);  pinMode(i,OUTPUT); }
		// and so do the control pins
		_rs_pin = rs;   digitalWrite(_rs_pin,HIGH);  pinMode(_rs_pin,OUTPUT);
		_wr_pin = wr;   digitalWrite(_wr_pin,HIGH);  pinMode(_wr_pin,OUTPUT);
		_cs_pin = cs;   digitalWrite(_cs_pin,HIGH);  pinMode(_cs_pin,OUTPUT);
		_rst_pin = rst; digitalWrite(_rst_pin,HIGH); pinMode(_rst_pin,OUTPUT);
	}
private:
	void chip_select() { digitalWrite(_cs_pin, LOW); }

	void chip_deselect() { digitalWrite(_cs_pin, HIGH); }
	
	void chip_reset() {
		// perform a complete reset
		digitalWrite(_rst_pin,HIGH); delay(5);
		digitalWrite(_rst_pin,LOW); delay(20);
		digitalWrite(_rst_pin,HIGH); delay(20);
	}

	void write_page(Page * page, word index, word count) {
		digitalWrite(_rs_pin, HIGH); // all data
		for(word i=0; i<count; i++) {
			byte b = page->read_byte(index++); // get the next byte
			write_port(b); // send it to the port 
		}
	}
	
	void write_commands(word * data, word count) {
		for(word i=0; i<count; i++) {
			word w = data[i]; // get the next word
			if(w & 0x0100) {
				digitalWrite(_rs_pin, LOW); 		
				// R commands get automatic leading zero byte
				write_port(0);
			} else {
				digitalWrite(_rs_pin, HIGH); 		
			}
			write_port(w&0xFF); // write the lower byte value
			
		}
	}
	
	void write_port(byte b) {
		for(byte i=0; i<8; i++) { 
		  digitalWrite(i, (b&1)?HIGH:LOW ); 
		  b = b>>1; 
		}
		digitalWrite(_wr_pin, LOW); digitalWrite(_wr_pin, HIGH); // pulse the pin 
	}
};

#if defined (__AVR_ATmega32U4__) // ATmega32U4 (Teensy/Leonardo).

/*
 * This variant is much faster, but assumes the following mapping from LCD to Leonardo.
 * 
 * RS - Pin A4 (PF1)
 * WR - Pin A5 (PF0)
 * RD - 3.3v
 * D0 - Pin A3 (PF4)
 * D1 - Pin A2 (PF5)
 * D2 - Pin A1 (PF6)
 * D3 - Pin A0 (PF7)
 * D4 - Pin 8  (PB4)
 * D5 - Pin 9  (PB5)
 * D6 - Pin 10 (PB6)
 * D7 - Pin 11 (PB7)
 * CS - Pin 6  (PD7)
 * RST- Pin 7  (PE6)
 */
class ILI9325C_Leo : public ILI9325C {
public:
	ILI9325C_Leo() : ILI9325C() {
		// take over our pins
		PORTF |= 0xF3; DDRF |= 0xF3; // d0-3 in F4-7, WR and RS in F0,1
		PORTB |= 0xF0; DDRB |= 0xF0; // d4-7 in B4-7
		PORTD |= 0x80; DDRD |= 0x80; // CS in D7
		PORTE |= 0x40; DDRE |= 0x40; // RST in E6
	}
private:
	void chip_select() { PORTD &= ~0x80; }

	void chip_deselect() { PORTD |= 0x80; }
	
	void chip_reset() {
		// perform a complete reset
		PORTE |= 0x40; delay(5);
		PORTE &=~0x40; delay(20);
		PORTE |= 0x40; delay(20);
	}

	void write_page(Page * page, word index, word count) {
		PORTF |= 0x02; // all data
		for(word i=0; i<count; i++) {
			byte b = page->read_byte(index++); // get the next byte
			write_port(b); // send it to the port 
		}
	}
	
	void write_commands(word * data, word count) {
		for(word i=0; i<count; i++) {
			word w = data[i]; // get the next word
			if(w & 0x0100) {
				PORTF &=~0x02; 		
				// R commands get automatic leading zero byte
				write_port(0);
			} else {
				PORTF |= 0x02; 		
			}
			write_port(w&0xFF); // write the lower byte value
		}
	}
	
	static inline void write_port(byte b) {
		// setup the data byte
		PORTB = (PORTB & 0x0F) | (b & 0xF0);
		PORTF = (PORTF & 0x0F) | ((b & 0x0F) << 4);
		// pulse the WR pin
		PORTF &=~0x01; PORTF |= 0x01;
	}
};

#endif

#ifdef _SPI_H_INCLUDED

class ST7735 {
public:
	static const word NOP      = 0x00;
	static const word SWRESET  = 0x01;
	static const word RDDID    = 0x04;
	static const word RDDST    = 0x09;
	
	static const word SLPIN    = 0x10;
	static const word SLPOUT   = 0x11;
	static const word PTLON    = 0x12;
	static const word NORON    = 0x13;
	
	static const word INVOFF   = 0x20;
	static const word INVON    = 0x21;
	static const word DISPOFF  = 0x28;
	static const word DISPON   = 0x29;
	static const word CASET    = 0x2A;
	static const word RASET    = 0x2B;
	static const word RAMWR    = 0x2C;
	static const word RAMRD    = 0x2E;
	
	static const word PTLAR    = 0x30;
	static const word COLMOD   = 0x3A;
	static const word MADCTL   = 0x36;
	
	static const word FRMCTR1  = 0xB1;
	static const word FRMCTR2  = 0xB2;
	static const word FRMCTR3  = 0xB3;
	static const word INVCTR   = 0xB4;
	static const word DISSET5  = 0xB6;
	
	static const word PWCTR1   = 0xC0;
	static const word PWCTR2   = 0xC1;
	static const word PWCTR3   = 0xC2;
	static const word PWCTR4   = 0xC3;
	static const word PWCTR5   = 0xC4;
	static const word VMCTR1   = 0xC5;
	
	static const word RDID1    = 0xDA;
	static const word RDID2    = 0xDB;
	static const word RDID3    = 0xDC;
	static const word RDID4    = 0xDD;
	
	static const word PWCTR6   = 0xFC;
	
	static const word GMCTRP1  = 0xE0;
	static const word GMCTRN1  = 0xE1;

	// memory data access control flags
	static const byte MadCtlMY  = 0x80;
	static const byte MadCtlMX  = 0x40;
	static const byte MadCtlMV  = 0x20;
	static const byte MadCtlML  = 0x10;
	static const byte MadCtlBGR = 0x08;
	static const byte MadCtlMH  = 0x04;

	// Color definitions
	static const word BLACK   = 0x0000;
	static const word BLUE    = 0x1F00;
	static const word RED     = 0x00F8;
	static const word GREEN   = 0xE007;
	static const word CYAN    = 0xFF07;
	static const word MAGENTA = 0x1FF8;
	static const word YELLOW  = 0xE0FF; 
	static const word WHITE   = 0xFFFF;

};

PROGMEM prog_uchar ST7735_SPI_init0[] = {
	1,ST7735::SWRESET,
	0
};
PROGMEM prog_uchar ST7735_SPI_init1[] = {
	1,ST7735::SLPOUT,
	0
};
PROGMEM prog_uchar ST7735_SPI_init2[] = {
	4,ST7735::FRMCTR1,   //  3: Frame rate ctrl - normal mode, 3 args:
	  0x01, 0x2C, 0x2D,       //     Rate = fosc/(1x2+40) * (LINE+2C+2D)
	4,ST7735::FRMCTR2, //  4: Frame rate control - idle mode, 3 args:
	  0x01, 0x2C, 0x2D,       //     Rate = fosc/(1x2+40) * (LINE+2C+2D)
	7,ST7735::FRMCTR3,  //  5: Frame rate ctrl - partial mode, 6 args:
	  0x01, 0x2C, 0x2D,       //     Dot inversion mode
	  0x01, 0x2C, 0x2D,       //     Line inversion mode
	2,ST7735::INVCTR ,   //  6: Display inversion ctrl, 1 arg
	  0x07,                   //     No inversion
	4,ST7735::PWCTR1 ,  //  7: Power control, 3 args
	  0xA2,
	  0x02,                   //     -4.6V
	  0x84,                   //     AUTO mode
	2,ST7735::PWCTR2 ,  //  8: Power control, 1 arg
	  0xC5,                   //     VGH25 = 2.4C VGSEL = -10 VGH = 3 * AVDD
	3,ST7735::PWCTR3 ,  //  9: Power control, 2 args
	  0x0A,                   //     Opamp current small
	  0x00,                   //     Boost frequency
	3,ST7735::PWCTR4 ,  // 10: Power control, 2 args
	  0x8A,                   //     BCLK/2, Opamp current small & Medium low
	  0x2A,  
	3,ST7735::PWCTR5 ,   // 11: Power control, 2 args
	  0x8A, 0xEE,
	2,ST7735::VMCTR1 ,   // 12: Power control, 1 arg
	  0x0E,
	1,ST7735::INVOFF ,  // 13: Don't invert display, no args
	2,ST7735::MADCTL ,  // 14: Memory access control (directions), 1 arg:
	  0x00,    // 
	2,ST7735::COLMOD ,  // 15: set color mode, 1 arg,
	  0x05 ,                 //     16-bit color
	17,ST7735::GMCTRP1,  // 13: Magical unicorn dust, 16 args
	  0x09, 0x16, 0x09, 0x20, //     (seriously though, not sure what
	  0x21, 0x1B, 0x13, 0x19, //      these config values represent)
	  0x17, 0x15, 0x1E, 0x2B,
	  0x04, 0x05, 0x02, 0x0E,
	17,ST7735::GMCTRN1,  // 14: Sparkles and rainbows, 16 args 
	  0x0B, 0x14, 0x08, 0x1E, //     (ditto)
	  0x22, 0x1D, 0x18, 0x1E,
	  0x1B, 0x1A, 0x24, 0x2B,
	  0x06, 0x06, 0x02, 0x0F, 
	5,ST7735::CASET  , // 15: Column addr set, 4 args
	  0x00, 0x00,   //     XSTART = 0
	  0x00, 0x7F,   //     XEND = 129
	5,ST7735::RASET  ,  // 16: Row addr set, 4 args
	  0x00, 0x00,   //     YSTART = 0
	  0x00, 0x9F,   //     YEND = 159
	1,ST7735::NORON, // 17: Normal display on, no args, 10 ms delay
	0
};
PROGMEM prog_uchar ST7735_SPI_init3[] = {
	1,ST7735::DISPON,
	0
};

class ST7735_SPI : public Raster16, SPIDevice, ST7735 {
public:
	// chip mode flags
	static const byte ChipSelect  = 0x01;
	static const byte ChipCommand      = 0x02;
	// base MADCTL value
	byte madctl_base;
public:
	ST7735_SPI(){
		width = 128;
		height = 240;
		// madctl_base = 0xC8; // 
		madctl_base = 0x00; // 

	}

	void fragment(word x, word y, byte dir, Page * pixels, word index, word count) {
		// determine entry mode and cursor position
		byte mc;
		byte ra, ca, re, ce;
		switch(dir) {
			case Raster::RIGHT: mc = 0;                   ca = x; ra = y; ce = 127; re = 159; break;
			case Raster::DOWN:  mc = MadCtlMV;            ca = y; ra = x; ce = 159; re = 127; break;
			case Raster::LEFT:  mc = MadCtlMX;            ca = 127-x; ra = y; ce = 127; re = 159; break;
			case Raster::UP:    mc = MadCtlMV | MadCtlMY; ca = 159-y; ra = x; ce = 159; re = 127; break;
		}
		// write fragment prefix as quickly as possible
		chip_mode(ChipSelect | ChipCommand);
		SPDR = MADCTL; while(!(SPSR & _BV(SPIF))); 
		chip_mode(ChipSelect);
		SPDR = madctl_base ^ mc; while(!(SPSR & _BV(SPIF))); 
		chip_mode(ChipSelect | ChipCommand);
		SPDR = CASET; while(!(SPSR & _BV(SPIF))); 
		chip_mode(ChipSelect);
		SPDR = 0; while(!(SPSR & _BV(SPIF))); 
		SPDR = ca; while(!(SPSR & _BV(SPIF))); 
		SPDR = 0; while(!(SPSR & _BV(SPIF))); 
		SPDR = ce; while(!(SPSR & _BV(SPIF))); 
		chip_mode(ChipSelect | ChipCommand);
		SPDR = RASET; while(!(SPSR & _BV(SPIF))); 
		chip_mode(ChipSelect);
		SPDR = 0; while(!(SPSR & _BV(SPIF))); 
		SPDR = ra; while(!(SPSR & _BV(SPIF))); 
		SPDR = 0; while(!(SPSR & _BV(SPIF))); 
		SPDR = re; while(!(SPSR & _BV(SPIF))); 
		chip_mode(ChipSelect | ChipCommand);
		SPDR = RAMWR; while(!(SPSR & _BV(SPIF))); 		
		// now write out the pixel data
		chip_mode(ChipSelect);
		word ic = count * 2;
		byte b;
		for(word i=0; i<ic; i++) {
			// transfer the next byte
			// SPI.transfer(page->read_byte(index++)); 
			pixels->read(index++,&b,1);
			SPDR = b; // start next transfer
			while(!(SPSR & _BV(SPIF))); // wait for previous transfer to finish
		}		
		chip_mode(0);
	}
	
	word color(byte r, byte g, byte b) {
		word w = 0;
		w |= (r & 0xF8) << 8;
		w |= (g & 0xFC) << 3;
		w |= (b & 0xF8) >> 3;
		return w;
	}
	
	void spi() {
		SPI.setBitOrder(MSBFIRST);
		SPI.setDataMode(SPI_MODE0);
		SPI.setClockDivider(SPI_CLOCK_DIV2);
	}
	
	void start() {
		// take over the SPI bus
		spi();
		// perform a complete reset
		chip_reset();
		// initialize
		PROGMEM prog_uchar * stream[] = { ST7735_SPI_init0, ST7735_SPI_init1, ST7735_SPI_init2, ST7735_SPI_init3 };
		int pause[] = { 50,200,10,100 };
		for(byte i=0; i<4; i++) {
			NearProgramPage page(stream[i]);
			command_stream(&page);
			delay(pause[i]);
		}
		
	}
	
	void command_stream(Page * data) {
		word index = 0;
		byte b,c;	
		// loop for each command fragment
		bool more = true;
		while(more) {
			// read the next block count
			data->read(index++,&c,1);
			if(c) {
				// read the next byte and send it as a command
				chip_mode(ChipSelect | ChipCommand);
				data->read(index++,&b,1); c--;
				SPDR = b; // start next transfer
				// now send the following bytes as data
				if(c) {
					chip_mode(ChipSelect);
					while(c) {
						data->read(index++,&b,1); c--;
						while(!(SPSR & _BV(SPIF))); // wait for previous transfer to finish						
						SPDR = b; // start next transfer
					}
				}
				while(!(SPSR & _BV(SPIF))); // wait for previous transfer to finish						
			} else {
				// found the zero sentinel
				more = false;
			}
		}
	}

	void idle() {}
	void stop() {}
	void scroll(int y) { }
	virtual void chip_reset() = 0;
// private:
	virtual void chip_mode(byte mode) = 0;
	
};

#endif

/*
 * 
 */
class RasterDraw16 {
	Raster16 * raster;
public:
	RasterDraw16(Raster16 * raster) {
		this->raster = raster;
	}
	
	void rect_outline(int x, int y, int w, int h, word color) {
		// wrap the pixel color in a repeating WordPage
		WordPage pixels(color);
		// send the buffer as a fragment for each edge
		raster->fragment(x,     y,     Raster::RIGHT, &pixels, 0,w-1);
		raster->fragment(x+w-1, y,     Raster::DOWN,  &pixels, 0,h-1);
		raster->fragment(x+w-1, y+h-1, Raster::LEFT,  &pixels, 0,w-1);
		raster->fragment(x,     y+h-1, Raster::UP,    &pixels, 0,h-1);
	}
	
	void rect_fill(int x, int y, int w, int h, word color) {
		// wrap the pixel color in a repeating WordPage
		WordPage pixels(color);
		// send the buffer as a fragment for each scanline
		for(int i=0; i<h; i++) {
			raster->fragment(x,y+i,Raster::RIGHT, &pixels,0,w);
		}
	}

};

/*
 * 
 */
class RasterFont16 {
	Raster16 * raster;
	Page * font;
public:
	RasterFont16(Raster16 * raster, Page * font) {
		this->raster = raster;
		this->font = font;
	}
	
	void font_fill(int x, int y, word index, word count, word fg, word bg) {
		// create a fragment buffer
		word pixel[8];
		// and wrap it in an access page
		MemoryPage fragment(pixel);
		// repeat for the remaining font bytes
		while(count) {
			// consume the next font byte
			byte b = font->read_byte(index++); count--;
			// compile the fragment pixels from bits of foreground or background
			for(byte i = 0; i<8; i++) pixel[i] = (b&(1<<i)) ? fg : bg;
			// draw the fragment to the raster surface
			raster->fragment(x++,y,Raster::DOWN, &fragment, 0, 8);
		}
	}

	void font_outline(int x, int y, word index, word count, word fg) {
		// create a fragment buffer for the foreground color
		WordPage fragment(fg);
		// repeat for the remaining font bytes
		while(count) {
			// consume the next font byte
			byte b = font->read_byte(index++); count--;
			byte i = 0;
			int ys; byte yc;
			bool run = false;
			// draw vertical runs of foreground pixels
			while(i<8) {
				// consume the next run of background
				while( (i<8) && !(b & (1<<i)) ) i++;
				// remember where we started
				ys = y+i; yc = 0;
				// consume the next run of foreground
				while( (i<8) && (b & (1<<i)) ) { i++; yc++; }
				// draw a fragment, if we had one
				if(yc) { raster->fragment(x,ys,Raster::DOWN, &fragment, 0, yc); }
			}
			x++;
		}
	}
	
	void char_fill(int x, int y, byte ch, word fg, word bg) {
		font_fill(x,y,ch*5,5,fg,bg);
		// then one final fragment of entirely the background color
		WordPage fragment(bg);
		// draw the fragment to the raster surface
		raster->fragment(x+5,y,Raster::DOWN, &fragment, 0, 8);
	}
	
	void char_outline(int x, int y, byte ch, word fg) {
		font_outline(x,y,ch*5,5,fg);
	}
};

PROGMEM prog_uchar font_5x8_128[] = {
    0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
	0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
	0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
	0x18, 0x3C, 0x7E, 0x3C, 0x18,
	0x1C, 0x57, 0x7D, 0x57, 0x1C,
	0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
	0x00, 0x18, 0x3C, 0x18, 0x00,
	0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
	0x00, 0x18, 0x24, 0x18, 0x00,
	0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
	0x30, 0x48, 0x3A, 0x06, 0x0E,
	0x26, 0x29, 0x79, 0x29, 0x26,
	0x40, 0x7F, 0x05, 0x05, 0x07,
	0x40, 0x7F, 0x05, 0x25, 0x3F,
	0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
	0x7F, 0x3E, 0x1C, 0x1C, 0x08,
	0x08, 0x1C, 0x1C, 0x3E, 0x7F,
	0x14, 0x22, 0x7F, 0x22, 0x14,
	0x5F, 0x5F, 0x00, 0x5F, 0x5F,
	0x06, 0x09, 0x7F, 0x01, 0x7F,
	0x00, 0x66, 0x89, 0x95, 0x6A,
	0x60, 0x60, 0x60, 0x60, 0x60,
	0x94, 0xA2, 0xFF, 0xA2, 0x94,
	0x08, 0x04, 0x7E, 0x04, 0x08,
	0x10, 0x20, 0x7E, 0x20, 0x10,
	0x08, 0x08, 0x2A, 0x1C, 0x08,
	0x08, 0x1C, 0x2A, 0x08, 0x08,
	0x1E, 0x10, 0x10, 0x10, 0x10,
	0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
	0x30, 0x38, 0x3E, 0x38, 0x30,
	0x06, 0x0E, 0x3E, 0x0E, 0x06,
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x5F, 0x00, 0x00,
	0x00, 0x07, 0x00, 0x07, 0x00,
	0x14, 0x7F, 0x14, 0x7F, 0x14,
	0x24, 0x2A, 0x7F, 0x2A, 0x12,
	0x23, 0x13, 0x08, 0x64, 0x62,
	0x36, 0x49, 0x56, 0x20, 0x50,
	0x00, 0x08, 0x07, 0x03, 0x00,
	0x00, 0x1C, 0x22, 0x41, 0x00,
	0x00, 0x41, 0x22, 0x1C, 0x00,
	0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
	0x08, 0x08, 0x3E, 0x08, 0x08,
	0x00, 0x80, 0x70, 0x30, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x00, 0x60, 0x60, 0x00,
	0x20, 0x10, 0x08, 0x04, 0x02,
	0x3E, 0x51, 0x49, 0x45, 0x3E,
	0x00, 0x42, 0x7F, 0x40, 0x00,
	0x72, 0x49, 0x49, 0x49, 0x46,
	0x21, 0x41, 0x49, 0x4D, 0x33,
	0x18, 0x14, 0x12, 0x7F, 0x10,
	0x27, 0x45, 0x45, 0x45, 0x39,
	0x3C, 0x4A, 0x49, 0x49, 0x31,
	0x41, 0x21, 0x11, 0x09, 0x07,
	0x36, 0x49, 0x49, 0x49, 0x36,
	0x46, 0x49, 0x49, 0x29, 0x1E,
	0x00, 0x00, 0x14, 0x00, 0x00,
	0x00, 0x40, 0x34, 0x00, 0x00,
	0x00, 0x08, 0x14, 0x22, 0x41,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x00, 0x41, 0x22, 0x14, 0x08,
	0x02, 0x01, 0x59, 0x09, 0x06,
	0x3E, 0x41, 0x5D, 0x59, 0x4E,
	0x7C, 0x12, 0x11, 0x12, 0x7C,
	0x7F, 0x49, 0x49, 0x49, 0x36,
	0x3E, 0x41, 0x41, 0x41, 0x22,
	0x7F, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x49, 0x49, 0x49, 0x41,
	0x7F, 0x09, 0x09, 0x09, 0x01,
	0x3E, 0x41, 0x41, 0x51, 0x73,
	0x7F, 0x08, 0x08, 0x08, 0x7F,
	0x00, 0x41, 0x7F, 0x41, 0x00,
	0x20, 0x40, 0x41, 0x3F, 0x01,
	0x7F, 0x08, 0x14, 0x22, 0x41,
	0x7F, 0x40, 0x40, 0x40, 0x40,
	0x7F, 0x02, 0x1C, 0x02, 0x7F,
	0x7F, 0x04, 0x08, 0x10, 0x7F,
	0x3E, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x09, 0x09, 0x09, 0x06,
	0x3E, 0x41, 0x51, 0x21, 0x5E,
	0x7F, 0x09, 0x19, 0x29, 0x46,
	0x26, 0x49, 0x49, 0x49, 0x32,
	0x03, 0x01, 0x7F, 0x01, 0x03,
	0x3F, 0x40, 0x40, 0x40, 0x3F,
	0x1F, 0x20, 0x40, 0x20, 0x1F,
	0x3F, 0x40, 0x38, 0x40, 0x3F,
	0x63, 0x14, 0x08, 0x14, 0x63,
	0x03, 0x04, 0x78, 0x04, 0x03,
	0x61, 0x59, 0x49, 0x4D, 0x43,
	0x00, 0x7F, 0x41, 0x41, 0x41,
	0x02, 0x04, 0x08, 0x10, 0x20,
	0x00, 0x41, 0x41, 0x41, 0x7F,
	0x04, 0x02, 0x01, 0x02, 0x04,
	0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0x03, 0x07, 0x08, 0x00,
	0x20, 0x54, 0x54, 0x78, 0x40,
	0x7F, 0x28, 0x44, 0x44, 0x38,
	0x38, 0x44, 0x44, 0x44, 0x28,
	0x38, 0x44, 0x44, 0x28, 0x7F,
	0x38, 0x54, 0x54, 0x54, 0x18,
	0x00, 0x08, 0x7E, 0x09, 0x02,
	0x18, 0xA4, 0xA4, 0x9C, 0x78,
	0x7F, 0x08, 0x04, 0x04, 0x78,
	0x00, 0x44, 0x7D, 0x40, 0x00,
	0x20, 0x40, 0x40, 0x3D, 0x00,
	0x7F, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x41, 0x7F, 0x40, 0x00,
	0x7C, 0x04, 0x78, 0x04, 0x78,
	0x7C, 0x08, 0x04, 0x04, 0x78,
	0x38, 0x44, 0x44, 0x44, 0x38,
	0xFC, 0x18, 0x24, 0x24, 0x18,
	0x18, 0x24, 0x24, 0x18, 0xFC,
	0x7C, 0x08, 0x04, 0x04, 0x08,
	0x48, 0x54, 0x54, 0x54, 0x24,
	0x04, 0x04, 0x3F, 0x44, 0x24,
	0x3C, 0x40, 0x40, 0x20, 0x7C,
	0x1C, 0x20, 0x40, 0x20, 0x1C,
	0x3C, 0x40, 0x30, 0x40, 0x3C,
	0x44, 0x28, 0x10, 0x28, 0x44,
	0x4C, 0x90, 0x90, 0x90, 0x7C,
	0x44, 0x64, 0x54, 0x4C, 0x44,
	0x00, 0x08, 0x36, 0x41, 0x00,
	0x00, 0x00, 0x77, 0x00, 0x00,
	0x00, 0x41, 0x36, 0x08, 0x00,
	0x02, 0x01, 0x02, 0x04, 0x02,
	0x3C, 0x26, 0x23, 0x26, 0x3C,
	0x1E, 0xA1, 0xA1, 0x61, 0x12,
	0x3A, 0x40, 0x40, 0x20, 0x7A/*,
	0x38, 0x54, 0x54, 0x55, 0x59,
	0x21, 0x55, 0x55, 0x79, 0x41,
	0x21, 0x54, 0x54, 0x78, 0x41,
	0x21, 0x55, 0x54, 0x78, 0x40,
	0x20, 0x54, 0x55, 0x79, 0x40,
	0x0C, 0x1E, 0x52, 0x72, 0x12,
	0x39, 0x55, 0x55, 0x55, 0x59,
	0x39, 0x54, 0x54, 0x54, 0x59,
	0x39, 0x55, 0x54, 0x54, 0x58,
	0x00, 0x00, 0x45, 0x7C, 0x41,
	0x00, 0x02, 0x45, 0x7D, 0x42,
	0x00, 0x01, 0x45, 0x7C, 0x40,
	0xF0, 0x29, 0x24, 0x29, 0xF0,
	0xF0, 0x28, 0x25, 0x28, 0xF0,
	0x7C, 0x54, 0x55, 0x45, 0x00,
	0x20, 0x54, 0x54, 0x7C, 0x54,
	0x7C, 0x0A, 0x09, 0x7F, 0x49,
	0x32, 0x49, 0x49, 0x49, 0x32,
	0x32, 0x48, 0x48, 0x48, 0x32,
	0x32, 0x4A, 0x48, 0x48, 0x30,
	0x3A, 0x41, 0x41, 0x21, 0x7A,
	0x3A, 0x42, 0x40, 0x20, 0x78,
	0x00, 0x9D, 0xA0, 0xA0, 0x7D,
	0x39, 0x44, 0x44, 0x44, 0x39,
	0x3D, 0x40, 0x40, 0x40, 0x3D,
	0x3C, 0x24, 0xFF, 0x24, 0x24,
	0x48, 0x7E, 0x49, 0x43, 0x66,
	0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
	0xFF, 0x09, 0x29, 0xF6, 0x20,
	0xC0, 0x88, 0x7E, 0x09, 0x03,
	0x20, 0x54, 0x54, 0x79, 0x41,
	0x00, 0x00, 0x44, 0x7D, 0x41,
	0x30, 0x48, 0x48, 0x4A, 0x32,
	0x38, 0x40, 0x40, 0x22, 0x7A,
	0x00, 0x7A, 0x0A, 0x0A, 0x72,
	0x7D, 0x0D, 0x19, 0x31, 0x7D,
	0x26, 0x29, 0x29, 0x2F, 0x28,
	0x26, 0x29, 0x29, 0x29, 0x26,
	0x30, 0x48, 0x4D, 0x40, 0x20,
	0x38, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x38,
	0x2F, 0x10, 0xC8, 0xAC, 0xBA,
	0x2F, 0x10, 0x28, 0x34, 0xFA,
	0x00, 0x00, 0x7B, 0x00, 0x00,
	0x08, 0x14, 0x2A, 0x14, 0x22,
	0x22, 0x14, 0x2A, 0x14, 0x08,
	0xAA, 0x00, 0x55, 0x00, 0xAA,
	0xAA, 0x55, 0xAA, 0x55, 0xAA,
	0x00, 0x00, 0x00, 0xFF, 0x00,
	0x10, 0x10, 0x10, 0xFF, 0x00,
	0x14, 0x14, 0x14, 0xFF, 0x00,
	0x10, 0x10, 0xFF, 0x00, 0xFF,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x14, 0x14, 0x14, 0xFC, 0x00,
	0x14, 0x14, 0xF7, 0x00, 0xFF,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x14, 0x14, 0xF4, 0x04, 0xFC,
	0x14, 0x14, 0x17, 0x10, 0x1F,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0x1F, 0x00,
	0x10, 0x10, 0x10, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0xF0, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0xFF, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x14,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x00, 0x00, 0x1F, 0x10, 0x17,
	0x00, 0x00, 0xFC, 0x04, 0xF4,
	0x14, 0x14, 0x17, 0x10, 0x17,
	0x14, 0x14, 0xF4, 0x04, 0xF4,
	0x00, 0x00, 0xFF, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x14, 0x14, 0xF7, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x17, 0x14,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0xF4, 0x14,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x00, 0x00, 0x1F, 0x10, 0x1F,
	0x00, 0x00, 0x00, 0x1F, 0x14,
	0x00, 0x00, 0x00, 0xFC, 0x14,
	0x00, 0x00, 0xF0, 0x10, 0xF0,
	0x10, 0x10, 0xFF, 0x10, 0xFF,
	0x14, 0x14, 0x14, 0xFF, 0x14,
	0x10, 0x10, 0x10, 0x1F, 0x00,
	0x00, 0x00, 0x00, 0xF0, 0x10,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xFF,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x38, 0x44, 0x44, 0x38, 0x44,
	0x7C, 0x2A, 0x2A, 0x3E, 0x14,
	0x7E, 0x02, 0x02, 0x06, 0x06,
	0x02, 0x7E, 0x02, 0x7E, 0x02,
	0x63, 0x55, 0x49, 0x41, 0x63,
	0x38, 0x44, 0x44, 0x3C, 0x04,
	0x40, 0x7E, 0x20, 0x1E, 0x20,
	0x06, 0x02, 0x7E, 0x02, 0x02,
	0x99, 0xA5, 0xE7, 0xA5, 0x99,
	0x1C, 0x2A, 0x49, 0x2A, 0x1C,
	0x4C, 0x72, 0x01, 0x72, 0x4C,
	0x30, 0x4A, 0x4D, 0x4D, 0x30,
	0x30, 0x48, 0x78, 0x48, 0x30,
	0xBC, 0x62, 0x5A, 0x46, 0x3D,
	0x3E, 0x49, 0x49, 0x49, 0x00,
	0x7E, 0x01, 0x01, 0x01, 0x7E,
	0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
	0x44, 0x44, 0x5F, 0x44, 0x44,
	0x40, 0x51, 0x4A, 0x44, 0x40,
	0x40, 0x44, 0x4A, 0x51, 0x40,
	0x00, 0x00, 0xFF, 0x01, 0x03,
	0xE0, 0x80, 0xFF, 0x00, 0x00,
	0x08, 0x08, 0x6B, 0x6B, 0x08,
	0x36, 0x12, 0x36, 0x24, 0x36,
	0x06, 0x0F, 0x09, 0x0F, 0x06,
	0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x00,
	0x30, 0x40, 0xFF, 0x01, 0x01,
	0x00, 0x1F, 0x01, 0x01, 0x1E,
	0x00, 0x19, 0x1D, 0x17, 0x12,
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00*/
};



#endif
